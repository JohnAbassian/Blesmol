using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Mail;
using System.ServiceProcess;
using System.Threading;
using Blesmol.Core;
using Blesmol_FileSystem;
using Blesmol_SMTP;

namespace Blesmol {
	public partial class Service : ServiceBase {
		private readonly Config c = new Config();
		private DateTime? _DoNotSendUntilAfter;
		private Thread _WorkerThread;
		private Dictionary<DriveInfo, DriveStatus> _Drives;

		public Service() {
			InitializeComponent();
		}

		protected override void OnStart(String[] args) {
			c.LoadConfig();
			InitializeDrives();

			_WorkerThread = new Thread(new ThreadStart(MonitorDisks)) {
				Name = "workerThread"
			};
			_WorkerThread.Start();
		}

		private void InitializeDrives() {
			_Drives = new Dictionary<DriveInfo, DriveStatus>();

			foreach (DriveInfo driveInfo in DriveInfo.GetDrives()) {
				String name = driveInfo.Name.Replace(@":\", "");

				if (c.DisksToMonitor.Contains(name)) _Drives.Add(driveInfo, new DriveStatus() { DriveName = name });
			}
		}

		private void MonitorDisks() {
			for (; ; ) {
				if (_DoNotSendUntilAfter == null || DateTime.Now.CompareTo(_DoNotSendUntilAfter) == 1) {
					foreach ((DriveInfo driveInfo, DriveStatus driveStatus) in _Drives) {
						try {
							if (driveInfo.IsReady) {
								Boolean belowThreshold = CheckBelowThreshold(driveInfo.TotalSize, driveInfo.TotalFreeSpace, c.ThresholdAmount, c.ThresholdUnit);

								if (!belowThreshold && !driveStatus.Alerting) continue;

								driveStatus.Alerting = belowThreshold;

								SendAlerts(driveStatus.DriveName, c.ThresholdAmount.ToString(), c.ThresholdUnit, driveStatus.AlertTime, !driveStatus.Alerting);
							}
						} catch { }
					}
				}
				Thread.Sleep(TimeSpan.FromMinutes(_Drives.Any(x => x.Value.Alerting) ? c.EmailDelay : c.SleepInterval));
			}

			Boolean CheckBelowThreshold(Int64 driveSize, Int64 freeSpace, Double threshold, Units.Unit unit) {
				if (unit == Units.Unit.Percentage) return freeSpace <= (driveSize * (threshold / 100));
				else return freeSpace < Units.ConvertToBytes(c.ThresholdAmount, c.ThresholdUnit);
			}
		}

		private void SendAlerts(String drive, String thresholdAmount, Units.Unit thresholdUnit, DateTime eventTime, Boolean cleared) {
			_DoNotSendUntilAfter = DateTime.Now.AddMinutes(c.EmailDelay);


			SmtpClient mail = new SmtpClient(c.SmtpServer, Convert.ToInt32(c.SmtpServerPort)) {
				UseDefaultCredentials = false,
				Credentials = new System.Net.NetworkCredential(c.SmtpServerUsername, c.SmtpServerPassword),
				EnableSsl = true
			};

			String text = cleared ? "<p style='font-family:helvetica,arial,sans-serif;font-size:83%;'>Disk space is no longer low on " +
									c.MachineName + "<br/>Free space on " + drive + " is greater than " + thresholdAmount +
									thresholdUnit + " since " + eventTime + "<br/><br/><small>This is an automated email generated by Blesmol</small></p>"
										: "<p style='font-family:helvetica,arial,sans-serif;font-size:83%;'>Disk space is low on " +
										c.MachineName + "<br/>Free space on " + drive + " is less than " + thresholdAmount +
										thresholdUnit + " since " + eventTime + "<br/><br/><small>This is an automated email generated by Blesmol</small></p>";

			String subject = cleared ? "Disk space is no longer low on " + drive + " on " + c.MachineName : "Warning! Disk space is low on " + drive + " on " + c.MachineName;

			//foreach (MailMessage message in c.EmailAddresses.Select(email => new MailMessage("alerts@reliant.org", email,
			//	subject,
			//	text) {
			//	IsBodyHtml = true
			//})) {
			//	mail.Send(message);
			//}

			try {
				new BlesmolSMTPNotifier(new SMTPSettings(){Server = c.SmtpServer, Port = c.SmtpServerPort, Username = c.SmtpServerUsername, Password = c.SmtpServerPassword, UseSSLTLS = true}, c.EmailAddresses.ToList(), text, subject).Notify();
			} catch (Exception e) {
				FileLogger logger = new FileLogger();
				logger.Log(e, DateTime.Now);
			}
		}

		internal class DriveStatus {
			public String DriveName { get; set; }

			private Boolean _Alerting;
			public Boolean Alerting {
				get => _Alerting;
				set {
					if (value != _Alerting) AlertTime = DateTime.Now;

					_Alerting = value;
				}
			}

			public DateTime AlertTime { get; private set; }
		}

		protected override void OnStop() {
			_WorkerThread.Abort();
		}

		static void Main() {
#if DEBUG
			Service DebugService = new Service();
			DebugService.OnStart(null);
#else
            ServiceBase[] ServicesToRun;
            ServicesToRun = new ServiceBase[] 
			{ 
				new Service() 
			};
			ServiceBase.Run(ServicesToRun);
#endif
		}
	}

	internal static class Extensions {
		internal static void Deconstruct<T1, T2>(this KeyValuePair<T1, T2> tuple, out T1 key, out T2 value) {
			key = tuple.Key;
			value = tuple.Value;
		}
	}
}
